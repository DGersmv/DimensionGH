ПЛАН РАБОТ ДЛЯ Dimension_Gh (на базе Browser_Control)

ЦЕЛЬ V1:
Сделать add-on Dimension_Gh на базе Browser_Control, который:
- Корректно собирается под AC 29.
- Имеет своё имя, GUID’ы и ресурсные ID (никаких следов Browser_Control).
- Умеет принимать JSON-команду из браузера-панели типа: { "command": "Ping" } и отвечать.
- Имеет каркас команд под размеры: GetDimensions и CreateLinearDimension (пока можно без реальной логики, только заглушки).
Дальше этот же JSON-протокол мы подключим из Grasshopper.

--------------------------------------------------
ЭТАП 0. ПОДГОТОВКА ПРОЕКТА
--------------------------------------------------

1. Скопированную папку Browser_Control переименовать в Dimension_Gh.
   - Папка проекта: .../Examples/Dimension_Gh
   - Внутри: папка Src, RFIX/RINT, CMakeLists.txt, .sln/.vcxproj и т.д.

2. В Cursor:
   - Открыть корень .../Examples/Dimension_Gh как проект.
   - Убедиться, что это отдельный git-подпроект (при необходимости инициализировать git или хотя бы понимать, что это отдельная директория).

--------------------------------------------------
ЭТАП 1. ПЕРЕИМЕНОВАНИЕ И УНИКАЛЬНЫЕ ИДЕНТИФИКАТОРЫ
--------------------------------------------------

Задача: полностью отвязаться от старых строк "Browser_Control", "Browser Control", старых GUID’ов и ResourceID.

3. Пройтись по всем файлам проекта поиском по строкам:
   - "Browser_Control"
   - "Browser Control"
   - "BROWSER_CONTROL"
   - Имя старого add-on’а (из .grc / STR# "Add-on Name and Description")
   и заменить на:
   - В коде: "Dimension_Gh"
   - В ресурсах: "Dimension Gh" или "Dimension GH" — как решим, главное единообразно.

4. Обновить идентификаторы имён add-on’а:
   - В файле ресурсов (обычно RFIX/*.grc или RINT/*.grc) блок 'STR#' "Add-on Name and Description":
     - Имя add-on’а → "Dimension Gh"
     - Описание → что-то вроде "Grasshopper Dimension Bridge for Archicad".
   - В тех же ресурсах проверить меню, строки и подсказки — заменить старые названия на новые.

5. Обновить GUID add-on’а:
   - Найти в коде GUID (обычно в Main.cpp или отдельном AddOnId.hpp).
   - Сгенерировать новый GUID (через VS / онлайн).
   - Вставить его вместо старого во всех местах, где используется как идентификатор add-on’а.

6. Обновить номер разработчика/аддона если он захардкожен:
   - Проверить, нет ли где-то старых чисел DeveloperID / LocalID, если в Browser_Control они были отдельными.
   - Если есть — привести к схеме, используемой у тебя в других аддонах (REPL и т.п.), чтобы всё было согласованно.

--------------------------------------------------
ЭТАП 2. СБОРКА "ПУСТОГО" DIMENSION_GH
--------------------------------------------------

Цель: добиться, чтобы чисто переименованный аддон собрался и загрузился в Archicad 29 без новой логики.

7. Проверить/обновить CMakeLists.txt:
   - Имя проекта → "Dimension_Gh".
   - Путь к DevKit 29 — такой же, как в твоём актуальном Browser_Repl_Int для AC29.
   - Target name (библиотека) → Dimension_Gh (или как решим).
   - Убедиться, что ещё не тянутся лишние файлы/ресурсы, которые нам не нужны.

8. Если рядом есть .sln/.vcxproj:
   - Обновить имя проекта в .sln/.vcxproj (можно сделать через VS один раз).
   - Убедиться, что проект собирается в Release x64.

9. Собрать проект Dimension_Gh:
   - Убедиться, что .apx/.bundle попадает в правильную папку (как в примерах DevKit).
   - Добавить путь к add-on’у в Archicad / или положить его в нужную Add-Ons папку.

10. Запустить Archicad 29:
    - Проверить, что Dimension_Gh отображается в списке Add-On’ов.
    - Открыть меню/палитру, которую создаёт пример, и убедиться что она живёт под новыми строками (Dimension Gh).

На этом этапе функционал пока может быть "как в Browser_Control", главное — всё переименовано и работает.

--------------------------------------------------
ЭТАП 3. ВЫДЕЛИТЬ МОДУЛЬ МОСТА (BRIDGE)
--------------------------------------------------

Цель: вычленить/оформить код, который связывает HTML/JS и C++ через сообщения, чтобы использовать это как основу нашего JSON-моста.

11. Найти в Src файлы, связанные с браузером/контролом:
    - Как правило, это:
      - основной файл аддона (Main.cpp или имя проекта),
      - файл, который создаёт браузерную палитру,
      - обработчики сообщений из JS (callback’и, message handler).

12. В этих файлах:
    - Явно выделить место, где принимается сообщение от HTML/JS.
    - Понять, как формат данных передаётся: строка, JSON, отдельные параметры.
    - Если сообщение уже приходит как строка (JS → C++) — принять решение:
      - Использовать эту строку как JSON-запрос.
      - Ввести общий обработчик: HandleJsonRequest (string json).

13. Создать отдельные файлы для моста:
    - Src/Bridge.hpp
    - Src/Bridge.cpp
    В них оформить:
    - Функцию `GS::UniString HandleJsonRequest (const GS::UniString& jsonRequest);`
      (имя и сигнатуру можно уточнить, главное — один вход/выход).

14. В основном коде (там, где приходят сообщения из HTML/JS):
    - Заменить старую обработку на:
      - конвертацию входной строки в `GS::UniString`,
      - вызов `HandleJsonRequest`,
      - отправку результата обратно в JS.

На этом этапе:
- мост = связь HTML → JSON-строка → C++ → JSON-строка → HTML.
- Логика размеров пока не трогаем.

--------------------------------------------------
ЭТАП 4. JSON-КАРКАС КОМАНД (PING, ЗАГЛУШКИ ДЛЯ DIMENSIONS)
--------------------------------------------------

Цель: сделать простой протокол, который потом будет одинаков и для браузера, и для Grasshopper.

15. Определить JSON-формат:
    Ввод (запрос):
    {
      "command": "Ping",
      "payload": { ... }
    }

    Вывод (ответ):
    {
      "ok": true/false,
      "error": "текст ошибки или пусто",
      "result": { ... }
    }

16. В Bridge.cpp:
    - Реализовать парсинг JSON:
      - достать поле "command",
      - по switch/if вызывать разные обработчики команд.
    - На этапе V1:
      - Команда "Ping" — возвращает ok=true, result={ "message": "Dimension_Gh alive" }.
      - Команда "GetDimensions" — пока заглушка:
        ok=true, result пустой массив dimensions.
      - Команда "CreateLinearDimension" — заглушка: ok=true, но без реальных действий.

    (Реальную работу с API_DimensionType добавим на следующем этапе.)

17. В HTML/JS части Browser_Control:
    - Добавить простую кнопку "Ping".
    - По нажатию отправляется JSON { "command": "Ping" } в C++.
    - Показать ответ в каком-нибудь <div> (для быстрой отладки моста).

Проверка:
- Нажимаем кнопку Ping.
- Лампа в браузере (или надпись) показывает ответ от аддона.
- Значит, мост HTML ↔ C++ готов.

--------------------------------------------------
ЭТАП 5. ПОДГОТОВКА К РАБОТЕ С РАЗМЕРАМИ (API_DimensionType)
--------------------------------------------------

Цель:
